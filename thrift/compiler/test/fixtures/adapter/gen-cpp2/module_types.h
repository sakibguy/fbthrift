/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>



namespace apache {
namespace thrift {
namespace tag {
struct intField;
struct optionalIntField;
struct intFieldWithDefault;
struct setField;
struct optionalSetField;
struct mapField;
struct optionalMapField;
struct binaryField;
struct intField;
struct setField;
struct mapField;
struct binaryField;
struct structField;
struct optionalStructField;
struct structListField;
struct optionalStructListField;
struct unionField;
struct optionalUnionField;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_intField
#define APACHE_THRIFT_ACCESSOR_intField
APACHE_THRIFT_DEFINE_ACCESSOR(intField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_optionalIntField
#define APACHE_THRIFT_ACCESSOR_optionalIntField
APACHE_THRIFT_DEFINE_ACCESSOR(optionalIntField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intFieldWithDefault
#define APACHE_THRIFT_ACCESSOR_intFieldWithDefault
APACHE_THRIFT_DEFINE_ACCESSOR(intFieldWithDefault);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_setField
#define APACHE_THRIFT_ACCESSOR_setField
APACHE_THRIFT_DEFINE_ACCESSOR(setField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_optionalSetField
#define APACHE_THRIFT_ACCESSOR_optionalSetField
APACHE_THRIFT_DEFINE_ACCESSOR(optionalSetField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_mapField
#define APACHE_THRIFT_ACCESSOR_mapField
APACHE_THRIFT_DEFINE_ACCESSOR(mapField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_optionalMapField
#define APACHE_THRIFT_ACCESSOR_optionalMapField
APACHE_THRIFT_DEFINE_ACCESSOR(optionalMapField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_binaryField
#define APACHE_THRIFT_ACCESSOR_binaryField
APACHE_THRIFT_DEFINE_ACCESSOR(binaryField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intField
#define APACHE_THRIFT_ACCESSOR_intField
APACHE_THRIFT_DEFINE_ACCESSOR(intField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_setField
#define APACHE_THRIFT_ACCESSOR_setField
APACHE_THRIFT_DEFINE_ACCESSOR(setField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_mapField
#define APACHE_THRIFT_ACCESSOR_mapField
APACHE_THRIFT_DEFINE_ACCESSOR(mapField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_binaryField
#define APACHE_THRIFT_ACCESSOR_binaryField
APACHE_THRIFT_DEFINE_ACCESSOR(binaryField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structField
#define APACHE_THRIFT_ACCESSOR_structField
APACHE_THRIFT_DEFINE_ACCESSOR(structField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_optionalStructField
#define APACHE_THRIFT_ACCESSOR_optionalStructField
APACHE_THRIFT_DEFINE_ACCESSOR(optionalStructField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structListField
#define APACHE_THRIFT_ACCESSOR_structListField
APACHE_THRIFT_DEFINE_ACCESSOR(structListField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_optionalStructListField
#define APACHE_THRIFT_ACCESSOR_optionalStructListField
APACHE_THRIFT_DEFINE_ACCESSOR(optionalStructListField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_unionField
#define APACHE_THRIFT_ACCESSOR_unionField
APACHE_THRIFT_DEFINE_ACCESSOR(unionField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_optionalUnionField
#define APACHE_THRIFT_ACCESSOR_optionalUnionField
APACHE_THRIFT_DEFINE_ACCESSOR(optionalUnionField);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums

// END declare_enums
// BEGIN forward_declare
namespace cpp2 {
class Foo;
class Baz;
class Bar;
} // cpp2
// END forward_declare
// BEGIN typedefs
namespace cpp2 {
typedef ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::std::set<::std::string>> SetWithAdapter;
typedef ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>> ListWithElemAdapter;
typedef ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::Bar> StructWithAdapter;
typedef ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::Baz> UnionWithAdapter;

} // cpp2
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
namespace cpp2 {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class Foo final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Foo;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  Foo();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Foo(apache::thrift::FragileConstructor, ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> intField__arg, ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> optionalIntField__arg, ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> intFieldWithDefault__arg, ::cpp2::SetWithAdapter setField__arg, ::cpp2::SetWithAdapter optionalSetField__arg, ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>> mapField__arg, ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>> optionalMapField__arg, ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string> binaryField__arg);

  Foo(Foo&&) noexcept;

  Foo(const Foo& src);


  Foo& operator=(Foo&&) noexcept;
  Foo& operator=(const Foo& src);
  void __clear();

  ~Foo();

 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> intField;
 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> optionalIntField;
 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> intFieldWithDefault;
 private:
  ::cpp2::SetWithAdapter setField;
 private:
  ::cpp2::SetWithAdapter optionalSetField;
 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>> mapField;
 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>> optionalMapField;
 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string> binaryField;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool intField;
    bool optionalIntField;
    bool intFieldWithDefault;
    bool setField;
    bool optionalSetField;
    bool mapField;
    bool optionalMapField;
    bool binaryField;
    bool __fbthrift_get(folly::index_constant<0>) const {
      return intField;
    }
    void __fbthrift_set(folly::index_constant<0>, bool isset_flag) {
      intField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<1>) const {
      return optionalIntField;
    }
    void __fbthrift_set(folly::index_constant<1>, bool isset_flag) {
      optionalIntField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<2>) const {
      return intFieldWithDefault;
    }
    void __fbthrift_set(folly::index_constant<2>, bool isset_flag) {
      intFieldWithDefault = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<3>) const {
      return setField;
    }
    void __fbthrift_set(folly::index_constant<3>, bool isset_flag) {
      setField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<4>) const {
      return optionalSetField;
    }
    void __fbthrift_set(folly::index_constant<4>, bool isset_flag) {
      optionalSetField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<5>) const {
      return mapField;
    }
    void __fbthrift_set(folly::index_constant<5>, bool isset_flag) {
      mapField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<6>) const {
      return optionalMapField;
    }
    void __fbthrift_set(folly::index_constant<6>, bool isset_flag) {
      optionalMapField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<7>) const {
      return binaryField;
    }
    void __fbthrift_set(folly::index_constant<7>, bool isset_flag) {
      binaryField = isset_flag;
    }
  } __isset = {};

 public:

  bool operator==(const Foo&) const;
  bool operator<(const Foo&) const;

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> intField_ref() const& {
    return {this->intField, __isset.intField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> intField_ref() const&& {
    return {std::move(this->intField), __isset.intField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> intField_ref() & {
    return {this->intField, __isset.intField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> intField_ref() && {
    return {std::move(this->intField), __isset.intField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> optionalIntField_ref() const& {
    return {this->optionalIntField, __isset.optionalIntField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> optionalIntField_ref() const&& {
    return {std::move(this->optionalIntField), __isset.optionalIntField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> optionalIntField_ref() & {
    return {this->optionalIntField, __isset.optionalIntField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> optionalIntField_ref() && {
    return {std::move(this->optionalIntField), __isset.optionalIntField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> intFieldWithDefault_ref() const& {
    return {this->intFieldWithDefault, __isset.intFieldWithDefault};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> intFieldWithDefault_ref() const&& {
    return {std::move(this->intFieldWithDefault), __isset.intFieldWithDefault};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> intFieldWithDefault_ref() & {
    return {this->intFieldWithDefault, __isset.intFieldWithDefault};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> intFieldWithDefault_ref() && {
    return {std::move(this->intFieldWithDefault), __isset.intFieldWithDefault};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> setField_ref() const& {
    return {this->setField, __isset.setField};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> setField_ref() const&& {
    return {std::move(this->setField), __isset.setField};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> setField_ref() & {
    return {this->setField, __isset.setField};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> setField_ref() && {
    return {std::move(this->setField), __isset.setField};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> optionalSetField_ref() const& {
    return {this->optionalSetField, __isset.optionalSetField};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> optionalSetField_ref() const&& {
    return {std::move(this->optionalSetField), __isset.optionalSetField};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> optionalSetField_ref() & {
    return {this->optionalSetField, __isset.optionalSetField};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> optionalSetField_ref() && {
    return {std::move(this->optionalSetField), __isset.optionalSetField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> mapField_ref() const& {
    return {this->mapField, __isset.mapField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> mapField_ref() const&& {
    return {std::move(this->mapField), __isset.mapField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> mapField_ref() & {
    return {this->mapField, __isset.mapField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> mapField_ref() && {
    return {std::move(this->mapField), __isset.mapField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> optionalMapField_ref() const& {
    return {this->optionalMapField, __isset.optionalMapField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> optionalMapField_ref() const&& {
    return {std::move(this->optionalMapField), __isset.optionalMapField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> optionalMapField_ref() & {
    return {this->optionalMapField, __isset.optionalMapField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> optionalMapField_ref() && {
    return {std::move(this->optionalMapField), __isset.optionalMapField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> binaryField_ref() const& {
    return {this->binaryField, __isset.binaryField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> binaryField_ref() const&& {
    return {std::move(this->binaryField), __isset.binaryField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> binaryField_ref() & {
    return {this->binaryField, __isset.binaryField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> binaryField_ref() && {
    return {std::move(this->binaryField), __isset.binaryField};
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<Foo>;
  friend void swap(Foo& a, Foo& b);
};

template <class Protocol_>
uint32_t Foo::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class Baz final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Baz;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    intField = 1,
    setField = 4,
    mapField = 6,
    binaryField = 8,
  } ;

  Baz()
      : type_(Type::__EMPTY__) {}

  Baz(Baz&& rhs) noexcept
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intField:
      {
        set_intField(std::move(rhs.value_.intField));
        break;
      }
      case Type::setField:
      {
        set_setField(std::move(rhs.value_.setField));
        break;
      }
      case Type::mapField:
      {
        set_mapField(std::move(rhs.value_.mapField));
        break;
      }
      case Type::binaryField:
      {
        set_binaryField(std::move(rhs.value_.binaryField));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  Baz(const Baz& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::intField:
      {
        set_intField(rhs.value_.intField);
        break;
      }
      case Type::setField:
      {
        set_setField(rhs.value_.setField);
        break;
      }
      case Type::mapField:
      {
        set_mapField(rhs.value_.mapField);
        break;
      }
      case Type::binaryField:
      {
        set_binaryField(rhs.value_.binaryField);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  Baz& operator=(Baz&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intField:
      {
        set_intField(std::move(rhs.value_.intField));
        break;
      }
      case Type::setField:
      {
        set_setField(std::move(rhs.value_.setField));
        break;
      }
      case Type::mapField:
      {
        set_mapField(std::move(rhs.value_.mapField));
        break;
      }
      case Type::binaryField:
      {
        set_binaryField(std::move(rhs.value_.binaryField));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  Baz& operator=(const Baz& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::intField:
      {
        set_intField(rhs.value_.intField);
        break;
      }
      case Type::setField:
      {
        set_setField(rhs.value_.setField);
        break;
      }
      case Type::mapField:
      {
        set_mapField(rhs.value_.mapField);
        break;
      }
      case Type::binaryField:
      {
        set_binaryField(rhs.value_.binaryField);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~Baz() {
    __clear();
  }
  union storage_type {
    ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> intField;
    ::cpp2::SetWithAdapter setField;
    ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>> mapField;
    ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string> binaryField;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const Baz&) const;
  bool operator<(const Baz&) const;

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>& set_intField(::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> t = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>()) {
    __clear();
    type_ = Type::intField;
    ::new (std::addressof(value_.intField)) ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>(t);
    return value_.intField;
  }

  ::cpp2::SetWithAdapter& set_setField(::cpp2::SetWithAdapter const &t) {
    __clear();
    type_ = Type::setField;
    ::new (std::addressof(value_.setField)) ::cpp2::SetWithAdapter(t);
    return value_.setField;
  }

  ::cpp2::SetWithAdapter& set_setField(::cpp2::SetWithAdapter&& t) {
    __clear();
    type_ = Type::setField;
    ::new (std::addressof(value_.setField)) ::cpp2::SetWithAdapter(std::move(t));
    return value_.setField;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::cpp2::SetWithAdapter, T...>> ::cpp2::SetWithAdapter& set_setField(T&&... t) {
    __clear();
    type_ = Type::setField;
    ::new (std::addressof(value_.setField)) ::cpp2::SetWithAdapter(std::forward<T>(t)...);
    return value_.setField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>& set_mapField(::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>> const &t) {
    __clear();
    type_ = Type::mapField;
    ::new (std::addressof(value_.mapField)) ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>(t);
    return value_.mapField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>& set_mapField(::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>&& t) {
    __clear();
    type_ = Type::mapField;
    ::new (std::addressof(value_.mapField)) ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>(std::move(t));
    return value_.mapField;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>, T...>> ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>& set_mapField(T&&... t) {
    __clear();
    type_ = Type::mapField;
    ::new (std::addressof(value_.mapField)) ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>(std::forward<T>(t)...);
    return value_.mapField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>& set_binaryField(::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string> const &t) {
    __clear();
    type_ = Type::binaryField;
    ::new (std::addressof(value_.binaryField)) ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>(t);
    return value_.binaryField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>& set_binaryField(::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>&& t) {
    __clear();
    type_ = Type::binaryField;
    ::new (std::addressof(value_.binaryField)) ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>(std::move(t));
    return value_.binaryField;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>, T...>> ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>& set_binaryField(T&&... t) {
    __clear();
    type_ = Type::binaryField;
    ::new (std::addressof(value_.binaryField)) ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>(std::forward<T>(t)...);
    return value_.binaryField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> const& get_intField() const {
    if (type_ != Type::intField) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.intField;
  }

  ::cpp2::SetWithAdapter const& get_setField() const {
    if (type_ != Type::setField) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.setField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>> const& get_mapField() const {
    if (type_ != Type::mapField) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.mapField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string> const& get_binaryField() const {
    if (type_ != Type::binaryField) {
      ::apache::thrift::detail::throw_on_bad_field_access();
    }
    return value_.binaryField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>& mutable_intField() {
    assert(type_ == Type::intField);
    return value_.intField;
  }

  ::cpp2::SetWithAdapter& mutable_setField() {
    assert(type_ == Type::setField);
    return value_.setField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>& mutable_mapField() {
    assert(type_ == Type::mapField);
    return value_.mapField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>& mutable_binaryField() {
    assert(type_ == Type::binaryField);
    return value_.binaryField;
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t> move_intField() {
    assert(type_ == Type::intField);
    return std::move(value_.intField);
  }

  ::cpp2::SetWithAdapter move_setField() {
    assert(type_ == Type::setField);
    return std::move(value_.setField);
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>> move_mapField() {
    assert(type_ == Type::mapField);
    return std::move(value_.mapField);
  }

  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string> move_binaryField() {
    assert(type_ == Type::binaryField);
    return std::move(value_.binaryField);
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intField_ref() const& {
    return {value_.intField, type_, intField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intField_ref() const&& {
    return {std::move(value_.intField), type_, intField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intField_ref() & {
    return {value_.intField, type_, intField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intField_ref() && {
    return {std::move(value_.intField), type_, intField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> setField_ref() const& {
    return {value_.setField, type_, setField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> setField_ref() const&& {
    return {std::move(value_.setField), type_, setField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> setField_ref() & {
    return {value_.setField, type_, setField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::cpp2::SetWithAdapter>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> setField_ref() && {
    return {std::move(value_.setField), type_, setField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> mapField_ref() const& {
    return {value_.mapField, type_, mapField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> mapField_ref() const&& {
    return {std::move(value_.mapField), type_, mapField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> mapField_ref() & {
    return {value_.mapField, type_, mapField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter3, ::std::map<::std::string, ::apache::thrift::adapt_detail::adapted_t<my::Adapter2, ::cpp2::ListWithElemAdapter>>>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> mapField_ref() && {
    return {std::move(value_.mapField), type_, mapField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> binaryField_ref() const& {
    return {value_.binaryField, type_, binaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> binaryField_ref() const&& {
    return {std::move(value_.binaryField), type_, binaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> binaryField_ref() & {
    return {value_.binaryField, type_, binaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> binaryField_ref() && {
    return {std::move(value_.binaryField), type_, binaryField, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<Baz>;
  friend void swap(Baz& a, Baz& b);
};

template <class Protocol_>
uint32_t Baz::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
namespace cpp2 {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

class Bar final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = false;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = Bar;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  Bar();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Bar(apache::thrift::FragileConstructor, ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo> structField__arg, ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo> optionalStructField__arg, ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>> structListField__arg, ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>> optionalStructListField__arg, ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz> unionField__arg, ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz> optionalUnionField__arg);

  Bar(Bar&&) noexcept;

  Bar(const Bar& src);


  Bar& operator=(Bar&&) noexcept;
  Bar& operator=(const Bar& src);
  void __clear();

  ~Bar();

 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo> structField;
 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo> optionalStructField;
 private:
  ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>> structListField;
 private:
  ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>> optionalStructListField;
 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz> unionField;
 private:
  ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz> optionalUnionField;

 private:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool structField;
    bool optionalStructField;
    bool structListField;
    bool optionalStructListField;
    bool unionField;
    bool optionalUnionField;
    bool __fbthrift_get(folly::index_constant<0>) const {
      return structField;
    }
    void __fbthrift_set(folly::index_constant<0>, bool isset_flag) {
      structField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<1>) const {
      return optionalStructField;
    }
    void __fbthrift_set(folly::index_constant<1>, bool isset_flag) {
      optionalStructField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<2>) const {
      return structListField;
    }
    void __fbthrift_set(folly::index_constant<2>, bool isset_flag) {
      structListField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<3>) const {
      return optionalStructListField;
    }
    void __fbthrift_set(folly::index_constant<3>, bool isset_flag) {
      optionalStructListField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<4>) const {
      return unionField;
    }
    void __fbthrift_set(folly::index_constant<4>, bool isset_flag) {
      unionField = isset_flag;
    }
    bool __fbthrift_get(folly::index_constant<5>) const {
      return optionalUnionField;
    }
    void __fbthrift_set(folly::index_constant<5>, bool isset_flag) {
      optionalUnionField = isset_flag;
    }
  } __isset = {};

 public:

  bool operator==(const Bar&) const;
  bool operator<(const Bar&) const;

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structField_ref() const& {
    return {this->structField, __isset.structField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structField_ref() const&& {
    return {std::move(this->structField), __isset.structField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structField_ref() & {
    return {this->structField, __isset.structField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structField_ref() && {
    return {std::move(this->structField), __isset.structField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> optionalStructField_ref() const& {
    return {this->optionalStructField, __isset.optionalStructField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> optionalStructField_ref() const&& {
    return {std::move(this->optionalStructField), __isset.optionalStructField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> optionalStructField_ref() & {
    return {this->optionalStructField, __isset.optionalStructField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> optionalStructField_ref() && {
    return {std::move(this->optionalStructField), __isset.optionalStructField};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structListField_ref() const& {
    return {this->structListField, __isset.structListField};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structListField_ref() const&& {
    return {std::move(this->structListField), __isset.structListField};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structListField_ref() & {
    return {this->structListField, __isset.structListField};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structListField_ref() && {
    return {std::move(this->structListField), __isset.structListField};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> optionalStructListField_ref() const& {
    return {this->optionalStructListField, __isset.optionalStructListField};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> optionalStructListField_ref() const&& {
    return {std::move(this->optionalStructListField), __isset.optionalStructListField};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> optionalStructListField_ref() & {
    return {this->optionalStructListField, __isset.optionalStructListField};
  }

  template <typename..., typename T = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> optionalStructListField_ref() && {
    return {std::move(this->optionalStructListField), __isset.optionalStructListField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> unionField_ref() const& {
    return {this->unionField, __isset.unionField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> unionField_ref() const&& {
    return {std::move(this->unionField), __isset.unionField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> unionField_ref() & {
    return {this->unionField, __isset.unionField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> unionField_ref() && {
    return {std::move(this->unionField), __isset.unionField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> optionalUnionField_ref() const& {
    return {this->optionalUnionField, __isset.optionalUnionField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> optionalUnionField_ref() const&& {
    return {std::move(this->optionalUnionField), __isset.optionalUnionField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> optionalUnionField_ref() & {
    return {this->optionalUnionField, __isset.optionalUnionField};
  }

  template <typename..., typename T = ::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Baz>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> optionalUnionField_ref() && {
    return {std::move(this->optionalUnionField), __isset.optionalUnionField};
  }
  const ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>& get_structListField() const&;
  ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>> get_structListField() &&;

  template <typename T_Bar_structListField_struct_setter = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  [[deprecated("Use `FOO.structListField_ref() = BAR;` instead of `FOO.set_structListField(BAR);`")]]
  ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>& set_structListField(T_Bar_structListField_struct_setter&& structListField_) {
    structListField = std::forward<T_Bar_structListField_struct_setter>(structListField_);
    __isset.__fbthrift_set(folly::index_constant<2>(), true);
    return structListField;
  }
  const ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>* get_optionalStructListField() const&;
  ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>* get_optionalStructListField() &;
  ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>* get_optionalStructListField() && = delete;

  template <typename T_Bar_optionalStructListField_struct_setter = ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>>
  [[deprecated("Use `FOO.optionalStructListField_ref() = BAR;` instead of `FOO.set_optionalStructListField(BAR);`")]]
  ::std::vector<::apache::thrift::adapt_detail::adapted_t<my::Adapter1, ::cpp2::Foo>>& set_optionalStructListField(T_Bar_optionalStructListField_struct_setter&& optionalStructListField_) {
    optionalStructListField = std::forward<T_Bar_optionalStructListField_struct_setter>(optionalStructListField_);
    __isset.__fbthrift_set(folly::index_constant<3>(), true);
    return optionalStructListField;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<Bar>;
  friend void swap(Bar& a, Bar& b);
};

template <class Protocol_>
uint32_t Bar::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

} // cpp2
THRIFT_IGNORE_ISSET_USE_WARNING_END

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::cpp2::Baz::Type>;

template <> struct TEnumTraits<::cpp2::Baz::Type> {
  using type = ::cpp2::Baz::Type;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
